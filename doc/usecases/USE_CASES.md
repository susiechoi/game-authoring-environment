# Use cases
## Authoring Environment
1. **User changes a tower's range**: When the user clicks "Apply", an event handler will trigger a listener in AuthoringController to call the `applyChange` method, which will trigger the AuthoringModel to change the necessary instance variable (towerRange) in the AuthoringTower class. The correct AuthoringTower will be chosen based on the Tower's String name/ID.
2. **User is satisfied with their game and clicks "Demo."**: The AuthoringController has a listener on the "Demo" button. When the "Demo" button is clicked, AuthoringController invokes FileIO's FileWriter to save the state of the objects in the AuthoringModel. ChiefController has a listener on a BooleanProperty in AuthoringController which is changed when the state of the AuthoringModel has been successfully changed - upon which the ChiefController instantiates a new instance of game play using the path to the file with the AuthoringModel state that was saved. 
3. **User clicks "Demo" but has an incomplete path in their game.** Because the user cannot click "Apply" to temporarily change his or her changes with an incomplete path still on the screen, the most recently saved temporary game will be Demoed, and all changes not "Applied" will be lost. This protocol will be communicated to the user at the beginning of game authoring.
4.  **User creates a new kind of tower available during gameplay**: When the user clicks "Apply", an event handler will trigger a listener in AuthoringController to call the `applyChange` method, which will create a `new AuthoringTower()` populated with the necessary instance variables based on the user's input. 
5.  **User loads in new image file to depict an enemy:** When the user chooses the "new image" option, a menu to enter the filepath (or perhaps to navigate using the user's existing filesystem) of the new image. Once selected, a listener in ChiefController will trigger FileIO to save the image in the proper location in the game authoring filesystem. When the user clicks "Apply", an event handler will trigger a listener in AuthoringController to call the `applyChange` method, which will trigger the AuthoringModel to change the ImageView instance variable in the AuthoringTower class.  
6.  **User adds a new path to the level:** A new path object is created when the user hits the _create a path_ button. The user will be asked first to place the starting points and the end points for the path. Then the user can drag and drop path node objects into the view to connect the path. The path object will check to see that the start positions all connect to an end position before an _apply_ button becomes enabled. The apply button will reassign the path in the `AuthoringModel.java` class to be used in the game.
7.  **User wants another level but is too lazy to populate custom settings (auto-generate new levels):** Once the user launches the authoring environment, they can input the number of levels the want in a textfield. Beneath this input field there's also a checkbox that denotes _Consistent Level Layout_. If this is checked, the user will only need to generate one level layout that will be used for each level of the game. If the box is unchecked the user will have to generate each level individually through the authoring environment. 
8.  **User wants to customize how many enemy "waves" there are, and the composition of those waves:** The user is asked how many waves to include in each level. Then a menu to customize the wave is presented for each wave. The menu asks the user to input how many enemies should be included in the wave. This information is stored on the front end initially. A new menu is presented that allows the user to specify the number of each type of enemy in the level. The enemies available will be stored in `AuthoringModel.java`. Once the user specifies the amount for each enemy, the `AuthoringView.java` class ensures that the number for each enemy type sums to the total number of enemies in the wave. A new `Wave` object is created that holds the enemy types and the number associated with each. This object will be attached to the level being authored. 
9.  **User wants to return to main menu to start over without saving: The user clicks the _Home_ button.** This brings up a pop up display notifying the user that they will lose information. There are two buttons, one to _save_ and one to _exit_. If they select _exit_ the original menu screen is loaded. If they select _save_, a screen is created for them to name the game and save it. 
10. **User wants to specify which kind of attack ability a tower has (i.e. freezing, shooting, etc.)**: Upon creation of the DropdownMenu object (wrapping a ComboBox) that represents the tower attack type within the AuthoringView class, a Listener is placed on the user selection of an option in the DropdownMenu. A BooleanProperty instance variable in the AuthoringView class is listened to by AuthoringController; this BooleanProperty is changed when the user makes a selection, and separate AuthoringView instance variables are populated with information about the field the user changed (tower ability) and the value to which the user changed it. AuthoringController calls methods to get these values from AuthoringView when the BooleanProperty changes. AuthoringController then calls the `applyChange` method in AuthoringModel, which then applies an ability change to the appropriate Tower object.  
11. **User is in "Demo" mode and wants to return back to editing the game**: ChiefController is notified when the Return to Authoring/Editing button is clicked, upon which it switches its Scene from that provided by PlayController to that provided by AuthoringController. AuthoringController uses FileIO to load in the state of the authoring environment that the user previously left in order to demo. 
12. **User wants to specify custom starting value for player health:** Upon creation of the Resources screen, a Listener is placed on the "Apply" button at the bottom of the screen. A BooleanProperty instance variable in the AuthoringView class is listened to by AuthoringController; this BooleanProperty is changed when the user clicks the "Apply" button on the Resources screen. AuthoringController calls methods to get the values from the instance variables in the AuthoringView's Resources screen when the BooleanProperty changes. AuthoringController then calls the `applyChange` method in AuthoringModel, which then applies a change in health to the Resources object (along with the other changes that have been made to fields in the Resources screen).  
13. **User loads in a new background image**: FileChooser opens from the SettingsScreen, and the selected File is added to the library of background images that the user can choose from. Noting that a user action has occurred, the AuthoringController updates the SettingsScreen. Upon this update, AuthoringController ensures that FileIO is invoked to get the newest list of the files in the background images folder, which will be provided to SettingsScreen. SettingsScreen may then use the List of Files to create Image objects to display background image options to the user. 
14. **Designer changes the tower's damage**: For the designer to change a tower's damage, they must choose the Tower feature to edit. From there they are given the option to load in a previously defined tower or to create the a new one. Either way, the next step is to define the various attributes of the tower. One of these is damage. The designer can enter the desired value in a text field which will call setDamage(double damage) on the newly created Tower object.
15. **Designer changes the tower's cost**: See above use case, but change tower cost attribute instead of damage.
16. **Designer wants to add a custom theme song**: The custom theme song is a potential utility we discussed we haven't yet dicussed its implementation.
17. **Designer changes enemies' penalty to health (damage)**: The designer selects an enemy as feature to edit and edits its attributes to change its damage. This causes the AuthoringModel to instantiate a new (or edit an old) Enemy object and use setDamage(double damage)
18. **User is in Demo mode and would like to toggle back to the authoring environment**: The "Return to Authoring" button will only appear in gameplay when the Game Engine is instantiated as a result of pressing the "Demo" button (a different subclass of the Game Engine will be instantiated). This button will have a listener on in which will trigger ChiefController to instantiate the authoring environment and load in the game that was previously being played. Then, the AuthoringController can work as normal to allow continued editing of the game.
19. **User wants to delete an element of the path (drags a path block to the trash icon)**: Once the user clicks "Apply", the listener on the Apply button triggers Authoring Controller to call the Authoring Model, which then removes the Path object from its List of objects. 
20. **User wants to make a path but is too lazy to click and drag path elements one by one (can drag the path block)**: If the user right clicks to drag a block rather than left clicking, and the mouse hovers over a region not populated by a block, AuthoringController triggers AuthoringModel to create a new PathBlock objects and add it to the list of PathBlock objects contained in the current Level.

## Engine/GamePlay
21. **User wants to place a tower:** The user will click on an available tower on the right side of the screen. Then, the front end will have an ImageView of the Tower follow the users mouse until they click again, in which case the tower is placed. The front end calls `GameState.placeTower (name, xcoord, ycoord)`. In placeTower, it calls `TowerData.createTower(name, xcoord, ycoord)` where TowerData uses the saved xml information for that type of tower (which is saved in a map with the name as a key) to create a Tower object. This Tower object is returned to GameState where it is added to the set of Towers.
22. **Tower shoots a projectile at the furthest enemy:** On every iteration of the GameLoop, `GameState.update()` is called. This will loop through all the Enemies in order and ask `Tower.inRange(Enemy)`. If this is true, then `Tower.fire(Enemy)` is called, which will use the Launcher to Launch a projectile at that enemy. However, it only fires if the Launcher is able to fire (based on rateOfFire). There will be a millisecond counter that is reset every fire. Also, the loop of enemies stops when one is inRange() and the next tower in the set then starts to loop through. 
23. **User sells current tower:** User sells current tower. The tower is clicked on and then an information screen pops up. The SELL button is then clicked. The front-end passes the tower `GameState.SellTower(Tower)`. Then, this tower is picked out of the set and first `Tower.sell()` is called. This returns how much the tower sells for, and `Money.add(amount)` is called to update how much money the user has. There is a listener for this in the front end, and the front end will then update the display accordingly. Still in `GameState.SellTower(Tower)`, the tower is removed from the set. 
24. **User purchases tower upgrade:** The tower is clicked on and then an information screen pops up. The UPGRADE button is then clicked. The front-end passes the tower `GameState.UpgradeTower()`. Then, the `Tower.upgrade()` method is called. In Tower, there is an `Upgrade()` object. Through the use of composition, that `Upgrade.execute(this)` method is called, in which the parameters that were passed in via the XML are now upgraded to this Tower. This will update everything in the tower (including imageView), and so the resulting tower is then displayed on the front end by sending back a front end tower object. 
25. **User clicks ‘Start’ to initiate play:** The user clicks the start button and a window pops up, requesting the user to choose an XML file. Once the user selects a filepath, the program calls the XML reader `createEngine()` method, which draws information from the XML file at the specified filepath to create an instance of a game engine that is capable of applying the rules outlined in the XML file. A Game Loop is also instantiated based on the engine that is created, allowing the program to display the GUI. The game is now ready to be played.
26. **User chooses to play game with misformatted file:** The user clicks the start button and a window pops up, requesting the user choose an XML file. The user chooses a file that is not of the correct format and clicks “ok.” A pop up window appears stating that the selected file is of the incorrect format. The user exits out of the window and must select a new file of the correct format.
27. **Enemy is hit by projectile:** For every iteration of the Game Loop within the Game State, the method `getHitBy()` in the Enemy class is called on all active projectiles using a Composite design pattern. `getHitBy()` calls the `overlap()` method (extended from the Intersect interface). If the `overlap()` method returns true, then the two objects collided and the Enemy’s health is decremented by the projectile’s damage value. The `getHitBy()` method returns true to the GameState class, which then prompts the Frontend to erase the Projectile image from the screen, and its corresponding backend is erased from the collection of active Projectiles. If the Enemy’s health is below 0, use case 6) occurs, where the Enemy loses enough damage to die. 
28. **Enemy loses damage and dies:** The Enemy has a finite health that is stored as a private instance variable. This instance variable is decremented when the Enemy intersects a projectile. If the `getHitBy()` method returns true for an Enemy object and a particular projectile, its health is decremented by the projectile’s worth. In the GameState class, if the `getHitBy()` method returns true, it is also checked if the Enemy is alive, in its `isAlive()` method, which essentially returns if its health is below zero. If not, the Enemy object disappears from the collection of spawned Enemies, and the User’s points are incremented by that Enemy’s value before it is finally removed.
29. **New tower is unlocked and shown on screen:** There are two cases in which a new tower is unlocked on the main screen: if enough user points are achieved, and the user jumps to a new level. A list of all possible Towers, including the points/level thresholds at which they should be upgraded, are located within the `TowerData` class. Unlocks are kept track of in an `UnlockListener` class, which uses the Observer design pattern to update Unlocks each time that a User’s points are updated or the Level changes. When enough points are reached to warrant a new Tower being unlocked, a Tower object is constructed in the UnlockListener and passed to the frontend as an immutable object for display.
30. **User wants to fast forward:** The user will click the fast forward button in the control panel. The ImageView for the fast forward button has its action-on-click linked to the `setGameSpeed(Integer)` in the GameScreen. This method then calls `setGameSpeed(integer)` in the Screen Manager class which calls the `setGameSpeed(integer)` method in the GameState class. This then calls the `setGameSpeed(integer)` method in the GameEngine which will increase the speed of the game loop, making the game fast forward. 
31. **User wants to pause/play:** The user will click the pause button in the control panel. The ImageView for the fast forward button has its action-on-click linked linked to the `setGameSpeed(0)` in the GameScreen. This method then calls `setGameSpeed(0)` in the Screen Manager class which calls the `setGameSpeed(0)` method in the GameState class. This then calls the `setGameSpeed(0)` method in the GameEngine which will increase the speed of the game loop, making the game fast forward. 
32. **Enemy gets past and user loses all health/lives:** Once the user loses all of their health/lives, that data will be sent from the backend back to the front end and prompt a pop-up to show that alerts the user that they have lost. The pop-up will show them their stats and give them the options to restart the current game version, restart the level they were on, or go back to the main menu. Whatever option they select, the ScreenManager will change the current screen and either restart the game or bring up the main menu.
33. **New level starts up:** When a new level starts up, the user will be prompted with a pop-up that welcomes them to the level and tells them to place their towers with the money they have. When a user clicks on an unlocked tower on the TowerPanel it will tell the back-end that they have chosen a specific tower. Then when the user clicks on the GameScreen, the DisplayTower class will send the specific tower’s x and y coordinates as well as the tower type to the backend. The user will then need to press the play button and the level will start.
34. **User saves their current Play:** The user clicks on the save icon on the bottom right of the `GameScreen` and the click is registered in the `ControlsPanel` class. From the controls panel the save method is passed through the ScreenManager into the `GameState` where a new XML writer object is created and parses data from game state into a new XML file.
35. **User needs help:** On both the main menu page, and in the game itself the user can find a help page. When the user clicks on the gear on the main menu it will create a HelpPopup and allow them to click on the Help button to open the class website for the project. If the user is in the game itself, they can click on the gear in the corner of the ControlsPanel and the same HelpPopup will show up.
36. **User Wants to Create a New Play:** The user uses a drop down menu to choose an XML file then clicks a button that says Start, both of which are in the Startup class.  This class holds an instance of EngineController, on which it calls `NewGame(FilePath pathToXML)`.  The `EngineController` then sets the GameEngine’s instance of `GameState` to this `GameState`.
37. **User kills all enemies:** The GameState class tests to see if all enemies are dead and that there are no more left to spawn this level. If this is true, it will call the `endOfLevel()` method in GameEngine. This will then pause the game using `setGameSpeed()`. GameEngine will then call the `jumpLevel()` in the EngineController. This will then call `getLevel(int I)` in the XML parser, which will return a new GameState for the next level. The EngineController will then call `setLevel()` in the GameEngine, replacing the current GameState. The EngineController will then call `endOfLevel()` in the EngineController class, which will call the `endOfLevel()` method in the Screen Manager. The Screen Manager will then call `endOfLevel()` in the GameScreen. This will load the nextLevelPopUp class onto the screen. Upon button click of the “continue” button,  the nextLevelPopUp class will call `continueToNextLevel()` in the GameScreen which will then call it in the ScreenManager. The ScreenManager will then call  `continueToNextLevel()` in the EngineController. This will then call `setGameSpeed(Integer)` in the GameEngine, starting the new level.
38. **User attempts to place tower in invalid space:** The user will click on an available tower on the right side of the screen. Then, the front end will have an ImageView of the Tower follow the users mouse until they click again, in which case the tower is placed. The front end calls `GameState.placeTower (name, xcoord, ycoord)`. The GameState will then test to see if the space clicked is valid. If it is not, no tower will be placed and the method will simply return.
39. **User wants to restart the level:** The user clicks the Menu button in ControlsPanel, which instantiates a MenuPopup class.  The user then clicks the Restart button.  This class calls the `restartLevel()` method in GameScreen, which calls restartLevel in the EngineController.  The EngineController then calls XML to parse the current XML file, and a GameState is returned to EngineController, which sets the GameEngine’s instance of GameState to this GameState.
40. **The user tries to buy a tower they can’t afford:** The user will click on an available tower on the right side of the screen. Then, the front end will have an ImageView of the Tower follow the users mouse until they click again, in which case the tower is placed. The front end calls `GameState.placeTower (name, xcoord, ycoord)`. In placeTower, it calls `TowerData.createTower(name, xcoord, ycoord)` where TowerData uses the saved xml information for that type of tower (which is saved in a map with the name as a key) to check the price of the tower against the current currency. Because the currency is less than the cost, it returns without constructing a tower.
