# Use cases
## Authoring Environment
1. The User can select/upgrade to a launcher that shoots projectiles from all sides.** This will require creating another launcher class that perhaps extends a launcher superclass and instead of shooting off one projectile at a time, shoots off a list of projectiles that are oriented at different angles. Further, if we make the property class more comprehensive, shooting type can be extended as a property and applied to launchers as needed.
2. Able to support enemies/towers with unlimited health/damage. This will require making another type of health property that doesn’t decrement health and instead maintains a constant value. It would also require making a separate ‘Unlimited’ damage property that doesn’t decrement either. 
3. Designer can support animation within the game screen (e.g. such as towers/enemies exploding). The user will be able to animate players, enemies, and collisions, such as with fire and ice, and sprites with emotions and movements. 
4.  User is able to choose properties so that each tower/enemy can have a variable amount. The user can select a variable amount of properties for each sprite. For example, the designer could add armour to an enemy or tower in addition to health.  
5. Designer develops towers & projectile separately such that a single tower may be associated with multiple projectiles, and multiple towers with the same projectile. This would require making the projectile-designing screen autonomous (i.e. a separate option in the CustomizeLevelScreen, rather than a component of the tower-designing process). The projectile-designing screen would also need to include the ability to assign the projectile to existing Towers. Thus, the tower object would be parameterized by a list of associated projectiles, rather than a single projectile. 
6. Designer can associate enemies with projectiles. The projectile-designing screen would also include the ability to assign the new projectile to existing enemies. A list of projectiles would be integrated to the enemy constructor. 
7. Designer decides on a color scheme that user should see during game play. Similar to the ability to switch CSS files in the authoring environment, the CustomizeResources/SettingsScreen would include a dropdown menu from which the designer can select a color scheme (CSS file) for gameplay. Upon loading the game, this CSS file would be added to the root’s stylesheets. 
8. Designer has multiple default style packs to choose from. Available style packs will be shown to the designer on the authoring environment start screen. Based on the user’s selection, different Properties files will be used to specify the paths for the available enemy/tower/projectile/path images for that style (e.g. wooden stake projectiles for a vampire-themed game vs. meteor projectiles for a solar system-themed game). 
9. Designer wants to allow the user to click during the game to destroy enemies themselves. The designer will be able to specify the damage that the click will do, the action displayed when the user clicks, and the number of clicks the user will be given.
10. Designer wants to specify whether Towers are “killable” or not. Tower health can be set to infinite and instead levels ending will be specified by loss of points or another metric.
11. Designer wants to create a message to be displayed between lives and for an incoming wave. When the player finishes a level or is about to experience a new wave of enemies, the message will appear however the designer specified.
12. Designer wants to create an interactive “instructions” screen that describes how the game is played. This will include information about each of the towers/enemies as well as the rules/object of the game, and will be accessible at any point by the player.
13. Designer wants to specify the time between waves. The designer will be able to adjust a slider to set the time, in seconds, between waves.
14. Designer wants to specify the time between enemies in a wave. The designer will be able to adjust a slider to set the time, in seconds, between waves. 
15. Designer wants to upgrade a tower to a new tower. Once the tower is fully upgraded, the upgrade button upgrades to a whole other tower. This allows for towers to be chained together in ‘upgrade paths’. 
16. Designer wants to create a tower that freezes enemies. When the user selects the button to Customize Shooting in the Tower authoring screen the user can select a projectile effect. Depending upon the effect selected, different sliders appear to adjust the magnitude of the effect. For example, if damage effect is selected the user can specify the damage inflicted but if freeze is selected the user can specify the freeze duration.  
17. A user wants to set the sound that a collision makes On the authoring side, they are customizing settings.  The clicks a dropdown for “Set collision sound”, and chooses an mp3 file that is in the sounds folder.  This adds to a map in the AuthoringView with the name of the event (collision) and the file path.
18. A projectile hitting an enemy makes a “boom” sound The collision has been detected in the play state and the relevant method has been called in Mediator. Mediator calls playSound(“String”) on the static class SoundFactory, and the sound is played.
19. User wants to turn the volume off Previously, a getMuteButton() call was made to SoundFactory which returned a button to add to an hbox or screen. The user would click the button, which would make an internal call to the mute() method in SoundFactory.  All future calls would do nothing until the volume is turned back on.  Alternatively, the mute() method could could called from elsewhere in the program.
20. User wants to change the background music The programmer made a previous call to SoundManager’s getMusicSelector() method and added the Node it returned to the screen.  The user can now select a song from that selector, and it will be set as the background song in SoundManager.  In the future, this may support searching and choosing songs in spotify.
21. A Tower fires a fire projectile that lights enemy on fire and does damage over 10 seconds. When the collision is detected, in the enemy.isHit(Projectile) method, instead of linearly assigning damage, there will be a method called that causes a constant decrease in health.
22. Projectiles can follow the users mouse. Instead of a projectile following the furthest enemy, some types of projectiles can be launched that follow the users mouse
23. User can shoot projectiles by clicking. The user can click on a spot and launch a projectile from a specific UserTower to that spot
24. Projectiles can increase their blast radius. So some projectiles can be “bombs” and detonate causing damage to a large radius.
25. User wishes to add a curved block to the path: When the user right clicks on a block an option appears to select from a selection of curved blocks of the same image to drag onto the path grid. (Or they are already populated within a scrollpane)
26. Multiplayer Feature: Two users wish to play the game at the same time on a split screen, they click on a “versus” option in the main menu screen.
27. Select all feature: The user wishes to select a group of blocks on the screen that can be dragged together, either to another position in the grid or to the trash can, or copy and paste the selected images.
28. Random path generation: The user wished to place a randomly created grid in the path grid, that changes each time the user presses a button.
29. User wants to change the volume of the game. The user clicks on the settings panel and then volume tab to bring up a pop-up with a slider with volume controls.
30. User wants to name their tower. The user clicks on the tower, then clicks on the information to pull up a pop-up to name the tower.
31. User wants to change the placement of the tower panel to the other side of the screen. The user can grab the panel with their mouse and click and drag it to the other side of the screen until it snaps in place.
32. User wants to skip to the end of the level. User will click on a new button in the settings tab that will fast forward through the entire level and then have a popup with the statistics of the round.
33. User clicks on a tower and then wants to access the control panel without selling the tower. The user clicks anywhere on the game panel which is not a tower
34. User wants to change language. The user will click on a settings button in the game player to access a drop down menu of the available languages. Upon selection and click of a apply button, the language of all prompts will change.
35. User wants to undo a tower placement. The user will have a limited amount of time to hit the undo button in the game panel. This will refund x% of the money spent, above what they would get from selling the tower
36. User wishes to use a cheat code The user will click on the settings button displaying the settings popup. From there they will select the cheat code option and enter thier cheat code. If valid, it will be applied to the game state
37. User wishes to generate random new model. The user clicks “Generate Random Model” button in authoring screen. This calls a method in the authoring package that generates a new AuthoringModel with random levels, waves, enemies, path, etc. 
38. User wishes to view game archives. For each authored game, there will be a high score list that records the top 10 scores all time on the machine that is running that game. If a user finishes a game and scores enough points to rank in the top 10, they will be prompted to enter a nickname and their score will be recorded to an xml file using methods from the xml factory. In the main menu, a user can select the “View High Scores” button, which prompts the user to choose an authored game to view the scores for and then reads the corresponding xml file to display the scores and the nicknames on a new screen.
39. Designer wants to implement enemies that can shoot at and damage towers. Similarly to the implementation in the tower design screen, designers will have the flexibility to assign a projectile with specified attributes (i.e. range, damage, etc). Our backend design already supports this functionality for enemies, so it’s just the matter of us implementing it on the authoring end.
40. Designer wishes to create movable towers. Just as the enemies are created with a speed, this will be extended unto the towers so that they will have the capability of moving. This can be done by either having them given a specified movement range/path so that they can move around shooting enemies that come within their range. Or, users will be able to control the tower’s movement using the arrow keys to follow enemies around and shoot them.

